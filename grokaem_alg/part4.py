# стратегия "разделяй и властвуй", основанная на рекурсии

# задача про поле:

# def the_biggest_square(a, b):  # построено на алгоритме Евклида
#     # базовый случай
#     if a / 2 == float(b):  # если длина = 2 ширины
#         return b  # можно разделить на 2 квадрата с длиной = ширине
#     # рекурсия, сводящая к базовому случаю
#     else:  # если есть остаток / слишком короткая длина
#         return the_biggest_square(b, a % (b * (a//b)))  # отделить два самых больших квадрата и работать с остатком


# print(the_biggest_square(1680, 640))


# задача на сумму чисел

 def summa(arr):  # сумма всех чисел массива
     # базовый случай
     if len(arr) == 1:  # если в массиве 1 число
         return arr[0]  # вернуть его
     else:  # сокращение с помощью рекурсии
         a = arr.pop(0)  # вытащили первое число из списка
         return a + summa(arr)  # складываем его с суммой остального массива


# print(summa([2, 4, 6]))


# задача на нахождение длины массива с помощью "разделяй и властвуй"


# def lenght(arr):
#     # базовый случай:
#     if not arr:  # если массив пуст
#         return 0
#     else:  # если в массиве есть элемент
#         return 1 + lenght(arr[1:])  # этот элемент + длина оставшегося массива


# print(lenght([2, 4, 6, 8]))


#  задача на нахождение наибольшего числа в массиве


# def maximum(arr):
#     # базовый случай
#     if len(arr) == 2:  # если в списке 2 элемента
#         return arr[0] if arr[0] > arr[1] else arr[1]  # сравнить их и вернуть наибольший
#     else:  # сокращающая рекурсия
#         return arr[0] if arr[0] > maximum(arr[1:]) else maximum(arr[1:])  # сравниваем первый элемент списка с
#         # максимумом оставшегося списка


# print(maximum([2, 4, 6, 8]))


# бинарный поиск по стратегии "разделяй и властвуй"


# def binary_search(arr, item):
#     max = len(arr) - 1
#     min = 0
#     guess = (max-min)//2  # находим середину с помощью границ списка ^^^
#     # базовый случай
#     if arr[guess] == item:  # если угадали
#         return arr[guess]  # выводим элемент !не индекс! потому что список будет сокращаться
#     else:
#         # сокращаем список и снова вызываем поиск
#         return binary_search(arr[guess+1:], item) if arr[guess] < item else binary_search(arr[:guess], item)


# print(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7))


# быстрая сортировка


# def quick_sort(arr):
#     if len(arr) < 2:  # базовый случай (1 элемент)
#         return arr
#     else:  # рекурсивный случай
#         # разделение
#         opora = arr[0]  # опора (любой элемент из списка)
#         before = [i for i in arr[1:] if i <= opora]  # подмассив элементов меньше опоры
#         after = [i for i in arr[1:] if i > opora]  # подмассив элементов больше опоры
#         return quick_sort(before) + [opora] + quick_sort(after)  # рекурсия (сортируем подмассивы)


# print(quick_sort([1, 5, 7, 2, 4, 3, 7, 13]))
